Model: grok-3-mini
Provider: grok
Evaluated: 2026-02-15T03:40:20.819344+00:00

=== TIMING ===
Response time: 67.16s

=== CODE EXTRACTION ===
Method: markdown_python
Syntax valid: YES

=== EXECUTION ===
Execution Error: can only concatenate tuple (not "int") to tuple

=== RAW RESPONSE ===
```python
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    if not grid:
        return 0, ""
    N = len(grid)
    memo = [[[None for _ in range(3)] for _ in range(N)] for _ in range(N)]
    
    def dp(i, j, mod3):
        if memo[i][j][mod3] is not None:
            return memo[i][j]
        
        if i == 0 and j == 0:
            if mod3 == 0:
                memo[i][j][mod3] = (grid[0][0], None, None, None, None)
            else:
                memo[i][j][mod3] = (float('-inf'), None, None, None, None)
            return memo[i][j]
        
        candidates = []
        previous_mod = (mod3 - 1) % 3
        
        if mod3 == 0:
            if i > 0 and j > 0:
                prev_result = dp(i-1, j-1, previous_mod)
                if prev_result[0] != float('-inf'):
                    candidates.append((prev_result[0] + grid[i][j], i-1, j-1, previous_mod, 'X'))
        else:
            if j > 0:
                prev_result = dp(i, j-1, previous_mod)
                if prev_result[0] != float('-inf'):
                    candidates.append((prev_result[0] + grid[i][j], i, j-1, previous_mod, 'R'))
            if i > 0:
                prev_result = dp(i-1, j, previous_mod)
                if prev_result[0] != float('-inf'):
                    candidates.append((prev_result[0] + grid[i][j], i-1, j, previous_mod, 'D'))
            if i > 0 and j > 0:
                prev_result = dp(i-1, j-1, previous_mod)
                if prev_result[0] != float('-inf'):
                    candidates.append((prev_result[0] + grid[i][j], i-1, j-1, previous_mod, 'X'))
        
        if candidates:
            max_candidate = max(candidates, key=lambda x: x[0])
            memo[i][j][mod3] = max_candidate
        else:
            memo[i][j][mod3] = (float('-inf'), None, None, None, None)
        
        return memo[i][j]
    
    dp_values = [dp(N-1, N-1, k) for k in range(3)]
    max_sum_index = max(range(3), key=lambda k: dp_values[k][0])
    max_sum = dp_values[max_sum_index][0]
    best_mod3 = max_sum_index
    
    i, j, mod3 = N-1, N-1, best_mod3
    path = ""
    while i > 0 or j > 0:
        _, prev_i, prev_j, prev_mod3, move = memo[i][j][mod3]
        path = move + path
        i, j, mod3 = prev_i, prev_j, prev_mod3
    
    return max_sum, path
```

=== EXTRACTED CODE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    if not grid:
        return 0, ""
    N = len(grid)
    memo = [[[None for _ in range(3)] for _ in range(N)] for _ in range(N)]
    
    def dp(i, j, mod3):
        if memo[i][j][mod3] is not None:
            return memo[i][j]
        
        if i == 0 and j == 0:
            if mod3 == 0:
                memo[i][j][mod3] = (grid[0][0], None, None, None, None)
            else:
                memo[i][j][mod3] = (float('-inf'), None, None, None, None)
            return memo[i][j]
        
        candidates = []
        previous_mod = (mod3 - 1) % 3
        
        if mod3 == 0:
            if i > 0 and j > 0:
                prev_result = dp(i-1, j-1, previous_mod)
                if prev_result[0] != float('-inf'):
                    candidates.append((prev_result[0] + grid[i][j], i-1, j-1, previous_mod, 'X'))
        else:
            if j > 0:
                prev_result = dp(i, j-1, previous_mod)
                if prev_result[0] != float('-inf'):
                    candidates.append((prev_result[0] + grid[i][j], i, j-1, previous_mod, 'R'))
            if i > 0:
                prev_result = dp(i-1, j, previous_mod)
                if prev_result[0] != float('-inf'):
                    candidates.append((prev_result[0] + grid[i][j], i-1, j, previous_mod, 'D'))
            if i > 0 and j > 0:
                prev_result = dp(i-1, j-1, previous_mod)
                if prev_result[0] != float('-inf'):
                    candidates.append((prev_result[0] + grid[i][j], i-1, j-1, previous_mod, 'X'))
        
        if candidates:
            max_candidate = max(candidates, key=lambda x: x[0])
            memo[i][j][mod3] = max_candidate
        else:
            memo[i][j][mod3] = (float('-inf'), None, None, None, None)
        
        return memo[i][j]
    
    dp_values = [dp(N-1, N-1, k) for k in range(3)]
    max_sum_index = max(range(3), key=lambda k: dp_values[k][0])
    max_sum = dp_values[max_sum_index][0]
    best_mod3 = max_sum_index
    
    i, j, mod3 = N-1, N-1, best_mod3
    path = ""
    while i > 0 or j > 0:
        _, prev_i, prev_j, prev_mod3, move = memo[i][j][mod3]
        path = move + path
        i, j, mod3 = prev_i, prev_j, prev_mod3
    
    return max_sum, path