Model: gpt-5.2-codex
Provider: openai_responses
Evaluated: 2026-02-05T21:31:28.758576+00:00

=== TIMING ===
Response time: 146.53s

=== CODE EXTRACTION ===
Method: direct
Syntax valid: YES

=== EXECUTION ===
Returned sum: 60
Calculated sum: 60
Sum matches: YES
Path valid: YES

=== RAW RESPONSE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    N = len(grid)
    if N == 0:
        return (0, "")
    dp = [[[0] * 3 for _ in range(N)] for __ in range(N)]
    move = [[[''] * 3 for _ in range(N)] for __ in range(N)]
    priority = {'R': 0, 'D': 1, 'X': 2}

    for r in range(N - 1, -1, -1):
        for c in range(N - 1, -1, -1):
            for mod in range(3):
                if r == N - 1 and c == N - 1:
                    dp[r][c][mod] = grid[r][c]
                    move[r][c][mod] = ''
                else:
                    mod_next = (mod + 1) % 3
                    diag_possible = (r + 1 < N and c + 1 < N)
                    if mod == 2 and diag_possible:
                        dp[r][c][mod] = grid[r][c] + dp[r + 1][c + 1][mod_next]
                        move[r][c][mod] = 'X'
                    else:
                        best = None
                        best_move = ''
                        if c + 1 < N:
                            val = grid[r][c] + dp[r][c + 1][mod_next]
                            if best is None or val > best or (val == best and priority['R'] < priority[best_move]):
                                best = val
                                best_move = 'R'
                        if r + 1 < N:
                            val = grid[r][c] + dp[r + 1][c][mod_next]
                            if best is None or val > best or (val == best and priority['D'] < priority[best_move]):
                                best = val
                                best_move = 'D'
                        if diag_possible:
                            val = grid[r][c] + dp[r + 1][c + 1][mod_next]
                            if best is None or val > best or (val == best and priority['X'] < priority[best_move]):
                                best = val
                                best_move = 'X'
                        dp[r][c][mod] = best
                        move[r][c][mod] = best_move

    r = c = 0
    mod = 0
    path = []
    while not (r == N - 1 and c == N - 1):
        m = move[r][c][mod]
        if m == '':
            break
        path.append(m)
        if m == 'R':
            c += 1
        elif m == 'D':
            r += 1
        else:
            r += 1
            c += 1
        mod = (mod + 1) % 3
    return (dp[0][0][0], ''.join(path))

=== EXTRACTED CODE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    N = len(grid)
    if N == 0:
        return (0, "")
    dp = [[[0] * 3 for _ in range(N)] for __ in range(N)]
    move = [[[''] * 3 for _ in range(N)] for __ in range(N)]
    priority = {'R': 0, 'D': 1, 'X': 2}

    for r in range(N - 1, -1, -1):
        for c in range(N - 1, -1, -1):
            for mod in range(3):
                if r == N - 1 and c == N - 1:
                    dp[r][c][mod] = grid[r][c]
                    move[r][c][mod] = ''
                else:
                    mod_next = (mod + 1) % 3
                    diag_possible = (r + 1 < N and c + 1 < N)
                    if mod == 2 and diag_possible:
                        dp[r][c][mod] = grid[r][c] + dp[r + 1][c + 1][mod_next]
                        move[r][c][mod] = 'X'
                    else:
                        best = None
                        best_move = ''
                        if c + 1 < N:
                            val = grid[r][c] + dp[r][c + 1][mod_next]
                            if best is None or val > best or (val == best and priority['R'] < priority[best_move]):
                                best = val
                                best_move = 'R'
                        if r + 1 < N:
                            val = grid[r][c] + dp[r + 1][c][mod_next]
                            if best is None or val > best or (val == best and priority['D'] < priority[best_move]):
                                best = val
                                best_move = 'D'
                        if diag_possible:
                            val = grid[r][c] + dp[r + 1][c + 1][mod_next]
                            if best is None or val > best or (val == best and priority['X'] < priority[best_move]):
                                best = val
                                best_move = 'X'
                        dp[r][c][mod] = best
                        move[r][c][mod] = best_move

    r = c = 0
    mod = 0
    path = []
    while not (r == N - 1 and c == N - 1):
        m = move[r][c][mod]
        if m == '':
            break
        path.append(m)
        if m == 'R':
            c += 1
        elif m == 'D':
            r += 1
        else:
            r += 1
            c += 1
        mod = (mod + 1) % 3
    return (dp[0][0][0], ''.join(path))