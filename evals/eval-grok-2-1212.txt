Model: grok-2-1212
Provider: grok
Evaluated: 2026-01-15T07:22:05.396649+00:00

=== TIMING ===
Response time: 4.14s

=== CODE EXTRACTION ===
Method: markdown_python
Syntax valid: YES

=== EXECUTION ===
Execution Error: list index out of range

=== RAW RESPONSE ===
```python
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    n = len(grid)
    dp = [[(-float('inf'), '') for _ in range(n)] for _ in range(n)]
    dp[0][0] = (grid[0][0], '')

    def valid_move(i, j, move_count):
        if move_count % 3 == 2:  # Every 3rd move must be diagonal if possible
            if i + 1 < n and j + 1 < n:
                return [(i + 1, j + 1, 'X')]
        else:
            moves = []
            if i + 1 < n:
                moves.append((i + 1, j, 'D'))
            if j + 1 < n:
                moves.append((i + 1, j, 'R'))
            if i + 1 < n and j + 1 < n:
                moves.append((i + 1, j + 1, 'X'))
            return moves

    for move_count in range(n * 2 - 1):
        for i in range(n):
            for j in range(n):
                if dp[i][j][0] == -float('inf'):
                    continue
                for next_i, next_j, move in valid_move(i, j, move_count):
                    new_sum = dp[i][j][0] + grid[next_i][next_j]
                    new_path = dp[i][j][1] + move
                    if new_sum > dp[next_i][next_j][0]:
                        dp[next_i][next_j] = (new_sum, new_path)

    return dp[n-1][n-1]
```

=== EXTRACTED CODE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    n = len(grid)
    dp = [[(-float('inf'), '') for _ in range(n)] for _ in range(n)]
    dp[0][0] = (grid[0][0], '')

    def valid_move(i, j, move_count):
        if move_count % 3 == 2:  # Every 3rd move must be diagonal if possible
            if i + 1 < n and j + 1 < n:
                return [(i + 1, j + 1, 'X')]
        else:
            moves = []
            if i + 1 < n:
                moves.append((i + 1, j, 'D'))
            if j + 1 < n:
                moves.append((i + 1, j, 'R'))
            if i + 1 < n and j + 1 < n:
                moves.append((i + 1, j + 1, 'X'))
            return moves

    for move_count in range(n * 2 - 1):
        for i in range(n):
            for j in range(n):
                if dp[i][j][0] == -float('inf'):
                    continue
                for next_i, next_j, move in valid_move(i, j, move_count):
                    new_sum = dp[i][j][0] + grid[next_i][next_j]
                    new_path = dp[i][j][1] + move
                    if new_sum > dp[next_i][next_j][0]:
                        dp[next_i][next_j] = (new_sum, new_path)

    return dp[n-1][n-1]