Model: grok-4-1-fast-reasoning
Provider: grok
Evaluated: 2026-02-15T03:43:38.573607+00:00

=== TIMING ===
Response time: 31.61s

=== CODE EXTRACTION ===
Method: markdown_python
Syntax valid: YES

=== EXECUTION ===
Returned sum: 60
Calculated sum: 60
Sum matches: YES
Path valid: YES

=== RAW RESPONSE ===
```python
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    N = len(grid)
    if N == 0:
        return 0, ""
    INF = float('inf')
    dp = [[[-INF for _ in range(3)] for _ in range(N)] for _ in range(N)]
    prev = [[[None for _ in range(3)] for _ in range(N)] for _ in range(N)]
    dp[0][0][0] = grid[0][0]
    for i in range(N):
        for j in range(N):
            for mod in range(3):
                if dp[i][j][mod] == -INF:
                    continue
                curr_sum = dp[i][j][mod]
                next_move_mod = (mod + 1) % 3
                is_must_x = (next_move_mod == 0)
                x_possible = (i + 1 < N and j + 1 < N)
                allowed = []
                if is_must_x:
                    if x_possible:
                        allowed.append(('X', 1, 1, 'X'))
                    else:
                        if j + 1 < N:
                            allowed.append(('R', 0, 1, 'R'))
                        if i + 1 < N:
                            allowed.append(('D', 1, 0, 'D'))
                else:
                    if j + 1 < N:
                        allowed.append(('R', 0, 1, 'R'))
                    if i + 1 < N:
                        allowed.append(('D', 1, 0, 'D'))
                    if x_possible:
                        allowed.append(('X', 1, 1, 'X'))
                for _, di, dj, ch in allowed:
                    ni = i + di
                    nj = j + dj
                    new_sum = curr_sum + grid[ni][nj]
                    new_mod = next_move_mod
                    if new_sum > dp[ni][nj][new_mod]:
                        dp[ni][nj][new_mod] = new_sum
                        prev[ni][nj][new_mod] = (i, j, mod, ch)
    max_sum = -INF
    best_mod = -1
    for m in range(3):
        if dp[N-1][N-1][m] > max_sum:
            max_sum = dp[N-1][N-1][m]
            best_mod = m
    if max_sum == -INF:
        return 0, ""
    path = []
    ci, cj, cm = N-1, N-1, best_mod
    while ci != 0 or cj != 0:
        p = prev[ci][cj][cm]
        pi, pj, pm, ch = p
        path.append(ch)
        ci, cj, cm = pi, pj, pm
    path.reverse()
    return int(max_sum), ''.join(path)
```

=== EXTRACTED CODE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    N = len(grid)
    if N == 0:
        return 0, ""
    INF = float('inf')
    dp = [[[-INF for _ in range(3)] for _ in range(N)] for _ in range(N)]
    prev = [[[None for _ in range(3)] for _ in range(N)] for _ in range(N)]
    dp[0][0][0] = grid[0][0]
    for i in range(N):
        for j in range(N):
            for mod in range(3):
                if dp[i][j][mod] == -INF:
                    continue
                curr_sum = dp[i][j][mod]
                next_move_mod = (mod + 1) % 3
                is_must_x = (next_move_mod == 0)
                x_possible = (i + 1 < N and j + 1 < N)
                allowed = []
                if is_must_x:
                    if x_possible:
                        allowed.append(('X', 1, 1, 'X'))
                    else:
                        if j + 1 < N:
                            allowed.append(('R', 0, 1, 'R'))
                        if i + 1 < N:
                            allowed.append(('D', 1, 0, 'D'))
                else:
                    if j + 1 < N:
                        allowed.append(('R', 0, 1, 'R'))
                    if i + 1 < N:
                        allowed.append(('D', 1, 0, 'D'))
                    if x_possible:
                        allowed.append(('X', 1, 1, 'X'))
                for _, di, dj, ch in allowed:
                    ni = i + di
                    nj = j + dj
                    new_sum = curr_sum + grid[ni][nj]
                    new_mod = next_move_mod
                    if new_sum > dp[ni][nj][new_mod]:
                        dp[ni][nj][new_mod] = new_sum
                        prev[ni][nj][new_mod] = (i, j, mod, ch)
    max_sum = -INF
    best_mod = -1
    for m in range(3):
        if dp[N-1][N-1][m] > max_sum:
            max_sum = dp[N-1][N-1][m]
            best_mod = m
    if max_sum == -INF:
        return 0, ""
    path = []
    ci, cj, cm = N-1, N-1, best_mod
    while ci != 0 or cj != 0:
        p = prev[ci][cj][cm]
        pi, pj, pm, ch = p
        path.append(ch)
        ci, cj, cm = pi, pj, pm
    path.reverse()
    return int(max_sum), ''.join(path)