Model: gemini-3-flash-preview
Provider: gemini
Evaluated: 2026-01-12T17:53:07.250867+00:00

=== TIMING ===
Response time: 95.21s

=== CODE EXTRACTION ===
Method: direct
Syntax valid: YES

=== EXECUTION ===
Returned sum: 60
Calculated sum: 60
Sum matches: YES
Path valid: YES

=== RAW RESPONSE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    N = len(grid)
    if N == 1:
        return grid[0][0], ""
    states = {(0, 0): (grid[0][0], "")}
    res_sum, res_path = -float('inf'), ""
    for k in range(1, 2 * N):
        nxt = {}
        is_3 = (k % 3 == 0)
        for (r, c), (s, p) in states.items():
            if r == N - 1 and c == N - 1:
                continue
            can_x = (r + 1 < N and c + 1 < N)
            moves = []
            if is_3:
                if can_x:
                    moves = [('X', r + 1, c + 1)]
                else:
                    if r + 1 < N:
                        moves.append(('D', r + 1, c))
                    if c + 1 < N:
                        moves.append(('R', r, c + 1))
            else:
                if r + 1 < N:
                    moves.append(('D', r + 1, c))
                if c + 1 < N:
                    moves.append(('R', r, c + 1))
                if can_x:
                    moves.append(('X', r + 1, c + 1))
            for char, nr, nc in moves:
                ns = s + grid[nr][nc]
                if (nr, nc) not in nxt or ns > nxt[(nr, nc)][0]:
                    nxt[(nr, nc)] = (ns, p + char)
        states = nxt
        if (N - 1, N - 1) in states:
            s, p = states[(N - 1, N - 1)]
            if s > res_sum:
                res_sum, res_path = s, p
    return int(res_sum), res_path

=== EXTRACTED CODE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    N = len(grid)
    if N == 1:
        return grid[0][0], ""
    states = {(0, 0): (grid[0][0], "")}
    res_sum, res_path = -float('inf'), ""
    for k in range(1, 2 * N):
        nxt = {}
        is_3 = (k % 3 == 0)
        for (r, c), (s, p) in states.items():
            if r == N - 1 and c == N - 1:
                continue
            can_x = (r + 1 < N and c + 1 < N)
            moves = []
            if is_3:
                if can_x:
                    moves = [('X', r + 1, c + 1)]
                else:
                    if r + 1 < N:
                        moves.append(('D', r + 1, c))
                    if c + 1 < N:
                        moves.append(('R', r, c + 1))
            else:
                if r + 1 < N:
                    moves.append(('D', r + 1, c))
                if c + 1 < N:
                    moves.append(('R', r, c + 1))
                if can_x:
                    moves.append(('X', r + 1, c + 1))
            for char, nr, nc in moves:
                ns = s + grid[nr][nc]
                if (nr, nc) not in nxt or ns > nxt[(nr, nc)][0]:
                    nxt[(nr, nc)] = (ns, p + char)
        states = nxt
        if (N - 1, N - 1) in states:
            s, p = states[(N - 1, N - 1)]
            if s > res_sum:
                res_sum, res_path = s, p
    return int(res_sum), res_path