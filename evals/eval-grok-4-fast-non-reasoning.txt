Model: grok-4-fast-non-reasoning
Provider: grok
Evaluated: 2026-02-15T03:44:10.214005+00:00

=== TIMING ===
Response time: 2.42s

=== CODE EXTRACTION ===
Method: markdown_python
Syntax valid: YES

=== EXECUTION ===
Returned sum: 73
Calculated sum: 15
Sum matches: NO
Path valid: NO
Path error: Move 3 must be diagonal (X) but was D

=== RAW RESPONSE ===
```python
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    n = len(grid)
    if n == 0:
        return 0, ""
    
    # dp[i][j][k] = (max_sum, path) to reach (i,j) with k % 3 moves made
    dp = [[[(0, "") for _ in range(3)] for _ in range(n)] for _ in range(n)]
    dp[0][0][0] = (grid[0][0], "")
    
    for i in range(n):
        for j in range(n):
            for k in range(3):
                if dp[i][j][k][0] == 0 and (i > 0 or j > 0):
                    continue
                current_sum, path = dp[i][j][k]
                next_moves = k + 1
                
                # Try right
                if j + 1 < n:
                    new_k = next_moves % 3
                    new_sum = current_sum + grid[i][j + 1]
                    new_path = path + "R"
                    if new_sum > dp[i][j + 1][new_k][0]:
                        dp[i][j + 1][new_k] = (new_sum, new_path)
                
                # Try down
                if i + 1 < n:
                    new_k = next_moves % 3
                    new_sum = current_sum + grid[i + 1][j]
                    new_path = path + "D"
                    if new_sum > dp[i + 1][j][new_k][0]:
                        dp[i + 1][j][new_k] = (new_sum, new_path)
                
                # Try diagonal
                if i + 1 < n and j + 1 < n:
                    new_k = next_moves % 3
                    new_sum = current_sum + grid[i + 1][j + 1]
                    new_path = path + "X"
                    if new_sum > dp[i + 1][j + 1][new_k][0]:
                        dp[i + 1][j + 1][new_k] = (new_sum, new_path)
    
    # Find max at bottom-right across all k
    max_sum = 0
    best_path = ""
    for k in range(3):
        if dp[n-1][n-1][k][0] > max_sum:
            max_sum = dp[n-1][n-1][k][0]
            best_path = dp[n-1][n-1][k][1]
    
    return max_sum, best_path
```

=== EXTRACTED CODE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    n = len(grid)
    if n == 0:
        return 0, ""
    
    # dp[i][j][k] = (max_sum, path) to reach (i,j) with k % 3 moves made
    dp = [[[(0, "") for _ in range(3)] for _ in range(n)] for _ in range(n)]
    dp[0][0][0] = (grid[0][0], "")
    
    for i in range(n):
        for j in range(n):
            for k in range(3):
                if dp[i][j][k][0] == 0 and (i > 0 or j > 0):
                    continue
                current_sum, path = dp[i][j][k]
                next_moves = k + 1
                
                # Try right
                if j + 1 < n:
                    new_k = next_moves % 3
                    new_sum = current_sum + grid[i][j + 1]
                    new_path = path + "R"
                    if new_sum > dp[i][j + 1][new_k][0]:
                        dp[i][j + 1][new_k] = (new_sum, new_path)
                
                # Try down
                if i + 1 < n:
                    new_k = next_moves % 3
                    new_sum = current_sum + grid[i + 1][j]
                    new_path = path + "D"
                    if new_sum > dp[i + 1][j][new_k][0]:
                        dp[i + 1][j][new_k] = (new_sum, new_path)
                
                # Try diagonal
                if i + 1 < n and j + 1 < n:
                    new_k = next_moves % 3
                    new_sum = current_sum + grid[i + 1][j + 1]
                    new_path = path + "X"
                    if new_sum > dp[i + 1][j + 1][new_k][0]:
                        dp[i + 1][j + 1][new_k] = (new_sum, new_path)
    
    # Find max at bottom-right across all k
    max_sum = 0
    best_path = ""
    for k in range(3):
        if dp[n-1][n-1][k][0] > max_sum:
            max_sum = dp[n-1][n-1][k][0]
            best_path = dp[n-1][n-1][k][1]
    
    return max_sum, best_path