Model: grok-2-vision-1212
Provider: grok
Evaluated: 2026-02-01T04:32:06.145443+00:00

=== TIMING ===
Response time: 3.39s

=== CODE EXTRACTION ===
Method: markdown_python
Syntax valid: YES

=== EXECUTION ===
Returned sum: 52
Calculated sum: 6
Sum matches: NO
Path valid: NO
Path error: Move 3 must be diagonal (X) but was D

=== RAW RESPONSE ===
```python
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    n = len(grid)
    dp = [[(float('-inf'), '') for _ in range(n)] for _ in range(n)]
    dp[0][0] = (grid[0][0], '')

    def is_valid(x, y):
        return 0 <= x < n and 0 <= y < n

    for i in range(n):
        for j in range(n):
            if i == 0 and j == 0:
                continue
            current_sum, path = float('-inf'), ''
            for dx, dy, move in [(1, 0, 'R'), (0, 1, 'D'), (1, 1, 'X')]:
                px, py = i - dx, j - dy
                if is_valid(px, py):
                    prev_sum, prev_path = dp[px][py]
                    new_sum = prev_sum + grid[i][j]
                    new_path = prev_path + move
                    if len(new_path) % 3 == 2 and move != 'X' and is_valid(i - 1, j - 1):
                        continue
                    if new_sum > current_sum:
                        current_sum, path = new_sum, new_path
            dp[i][j] = (current_sum, path)

    return dp[n - 1][n - 1]
```

=== EXTRACTED CODE ===
def solve_grid(grid: list[list[int]]) -> tuple[int, str]:
    n = len(grid)
    dp = [[(float('-inf'), '') for _ in range(n)] for _ in range(n)]
    dp[0][0] = (grid[0][0], '')

    def is_valid(x, y):
        return 0 <= x < n and 0 <= y < n

    for i in range(n):
        for j in range(n):
            if i == 0 and j == 0:
                continue
            current_sum, path = float('-inf'), ''
            for dx, dy, move in [(1, 0, 'R'), (0, 1, 'D'), (1, 1, 'X')]:
                px, py = i - dx, j - dy
                if is_valid(px, py):
                    prev_sum, prev_path = dp[px][py]
                    new_sum = prev_sum + grid[i][j]
                    new_path = prev_path + move
                    if len(new_path) % 3 == 2 and move != 'X' and is_valid(i - 1, j - 1):
                        continue
                    if new_sum > current_sum:
                        current_sum, path = new_sum, new_path
            dp[i][j] = (current_sum, path)

    return dp[n - 1][n - 1]