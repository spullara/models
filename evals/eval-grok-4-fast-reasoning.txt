Model: grok-4-fast-reasoning
Provider: grok
Evaluated: 2026-02-15T03:44:12.662224+00:00

=== TIMING ===
Response time: 24.34s

=== CODE EXTRACTION ===
Method: markdown_python
Syntax valid: YES

=== EXECUTION ===
Returned sum: 60
Calculated sum: 60
Sum matches: YES
Path valid: YES

=== RAW RESPONSE ===
```python
from functools import cache
from typing import Tuple

def solve_grid(grid: list[list[int]]) -> Tuple[int, str]:
    if not grid or not grid[0]:
        return (0, "")
    N = len(grid)
    @cache
    def rec(r: int, c: int, mod: int) -> Tuple[int, str]:
        if r == N - 1 and c == N - 1:
            return (grid[r][c], "")
        must_x = (mod == 2)
        candidates = []
        can_r = c + 1 < N
        can_d = r + 1 < N
        can_x = r + 1 < N and c + 1 < N
        if must_x:
            if can_x:
                candidates.append(('X', r + 1, c + 1))
            else:
                if can_r:
                    candidates.append(('R', r, c + 1))
                if can_d:
                    candidates.append(('D', r + 1, c))
        else:
            if can_r:
                candidates.append(('R', r, c + 1))
            if can_d:
                candidates.append(('D', r + 1, c))
            if can_x:
                candidates.append(('X', r + 1, c + 1))
        best_sum = float('-inf')
        best_path = ""
        new_mod = (mod + 1) % 3
        for move, nr, nc in candidates:
            sub_sum, sub_path = rec(nr, nc, new_mod)
            this_sum = grid[r][c] + sub_sum
            if this_sum > best_sum:
                best_sum = this_sum
                best_path = move + sub_path
        return (best_sum, best_path)
    return rec(0, 0, 0)
```

=== EXTRACTED CODE ===
from functools import cache
from typing import Tuple

def solve_grid(grid: list[list[int]]) -> Tuple[int, str]:
    if not grid or not grid[0]:
        return (0, "")
    N = len(grid)
    @cache
    def rec(r: int, c: int, mod: int) -> Tuple[int, str]:
        if r == N - 1 and c == N - 1:
            return (grid[r][c], "")
        must_x = (mod == 2)
        candidates = []
        can_r = c + 1 < N
        can_d = r + 1 < N
        can_x = r + 1 < N and c + 1 < N
        if must_x:
            if can_x:
                candidates.append(('X', r + 1, c + 1))
            else:
                if can_r:
                    candidates.append(('R', r, c + 1))
                if can_d:
                    candidates.append(('D', r + 1, c))
        else:
            if can_r:
                candidates.append(('R', r, c + 1))
            if can_d:
                candidates.append(('D', r + 1, c))
            if can_x:
                candidates.append(('X', r + 1, c + 1))
        best_sum = float('-inf')
        best_path = ""
        new_mod = (mod + 1) % 3
        for move, nr, nc in candidates:
            sub_sum, sub_path = rec(nr, nc, new_mod)
            this_sum = grid[r][c] + sub_sum
            if this_sum > best_sum:
                best_sum = this_sum
                best_path = move + sub_path
        return (best_sum, best_path)
    return rec(0, 0, 0)